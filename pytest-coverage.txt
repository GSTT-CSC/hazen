============================= test session starts ==============================
platform darwin -- Python 3.6.8, pytest-5.3.5, py-1.10.0, pluggy-0.13.1
rootdir: /Users/lj16/code/hazen
plugins: cov-2.7.1, celery-4.3.1
collected 164 items

tests/test_ghosting.py ........................                          [ 14%]
tests/test_hazenlib.py ....................                              [ 26%]
tests/test_models.py FF                                                  [ 28%]
tests/test_relaxometry.py .......................                        [ 42%]
tests/test_slice_position.py ....                                        [ 44%]
tests/test_slice_width.py ....................                           [ 56%]
tests/test_snr.py .........                                              [ 62%]
tests/test_spatial_resolution.py ....................................... [ 85%]
...............                                                          [ 95%]
tests/test_tools.py .....                                                [ 98%]
tests/test_uniformity.py ...                                             [100%]

=================================== FAILURES ===================================
__________________________ UserModelCase.test_avatar ___________________________

self = Engine(postgres://test_user:***@localhost:5432/hazen_test)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fe6f807b898>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.reraise(exc_type, exc_value, exc_tb)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tp = <class 'psycopg2.OperationalError'>
value = OperationalError('could not connect to server: Connection refused\n\tIs the server running on host "localhost" (127.0....ction refused\n\tIs the server running on host "localhost" (::1) and accepting\n\tTCP/IP connections on port 5432?\n',)
tb = <traceback object at 0x7fe6f63c3048>, cause = None

    def reraise(tp, value, tb=None, cause=None):
        if cause is not None:
            assert cause is not value, "Same cause emitted"
            value.__cause__ = cause
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
>       raise value

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fe6f807b7f0>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f807b588>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fe6f807b7f0>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fe6f807b7f0>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fe6f807b358>
cargs = ()
cparams = {'database': 'hazen_test', 'host': 'localhost', 'password': 'test_user_password', 'port': 5432, ...}

    def connect(self, *cargs, **cparams):
>       return self.dbapi.connect(*cargs, **cparams)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/default.py:453: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost user=test_user password=test_user_password port=5432 dbname=hazen_test'
connection_factory = None, cursor_factory = None
kwargs = {'database': 'hazen_test', 'host': 'localhost', 'password': 'test_user_password', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        if dsn is None and not kwargs:
            raise TypeError('missing dsn and no parameters')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not connect to server: Connection refused
E       	Is the server running on host "localhost" (127.0.0.1) and accepting
E       	TCP/IP connections on port 5432?
E       could not connect to server: Connection refused
E       	Is the server running on host "localhost" (::1) and accepting
E       	TCP/IP connections on port 5432?

../venv/hazen/lib/python3.6/site-packages/psycopg2/__init__.py:126: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_models.UserModelCase testMethod=test_avatar>

    def setUp(self):
        self.app = create_app(TestConfig)
        self.app_context = self.app.app_context()
        self.app_context.push()
>       db.create_all()

tests/test_models.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../venv/hazen/lib/python3.6/site-packages/flask_sqlalchemy/__init__.py:1033: in create_all
    self._execute_for_all_tables(app, bind, 'create_all')
../venv/hazen/lib/python3.6/site-packages/flask_sqlalchemy/__init__.py:1025: in _execute_for_all_tables
    op(bind=self.get_engine(app, bind), **extra)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/sql/schema.py:4287: in create_all
    ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2032: in _run_visitor
    with self._optional_conn_ctx_manager(connection) as conn:
/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/contextlib.py:81: in __enter__
    return next(self.gen)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2024: in _optional_conn_ctx_manager
    with self._contextual_connect() as conn:
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2226: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2266: in _wrap_pool_connect
    e, dialect, self
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1536: in _handle_dbapi_exception_noconnection
    util.raise_from_cause(sqlalchemy_exception, exc_info)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:383: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:128: in reraise
    raise value.with_traceback(tb)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2262: in _wrap_pool_connect
    return fn()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:363: in connect
    return _ConnectionFairy._checkout(self)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:760: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:492: in checkout
    rec = pool._do_get()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:139: in _do_get
    self._dec_overflow()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:129: in reraise
    raise value
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:136: in _do_get
    return self._create_connection()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:308: in _create_connection
    return _ConnectionRecord(self)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:437: in __init__
    self.__connect(first_connect_check=True)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:639: in __connect
    connection = pool._invoke_creator(self)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/default.py:453: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost user=test_user password=test_user_password port=5432 dbname=hazen_test'
connection_factory = None, cursor_factory = None
kwargs = {'database': 'hazen_test', 'host': 'localhost', 'password': 'test_user_password', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        if dsn is None and not kwargs:
            raise TypeError('missing dsn and no parameters')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not connect to server: Connection refused
E       	Is the server running on host "localhost" (127.0.0.1) and accepting
E       	TCP/IP connections on port 5432?
E       could not connect to server: Connection refused
E       	Is the server running on host "localhost" (::1) and accepting
E       	TCP/IP connections on port 5432?
E       
E       (Background on this error at: http://sqlalche.me/e/e3q8)

../venv/hazen/lib/python3.6/site-packages/psycopg2/__init__.py:126: OperationalError
------------------------------ Captured log call -------------------------------
INFO     flask.app:__init__.py:85 Hazen startup
_____________________ UserModelCase.test_password_hashing ______________________

self = Engine(postgres://test_user:***@localhost:5432/hazen_test)
fn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>>
connection = None

    def _wrap_pool_connect(self, fn, connection):
        dialect = self.dialect
        try:
>           return fn()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>

    def connect(self):
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
        if not self._use_threadlocal:
>           return _ConnectionFairy._checkout(self)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>
threadconns = None, fairy = None

    @classmethod
    def _checkout(cls, pool, threadconns=None, fairy=None):
        if not fairy:
>           fairy = _ConnectionRecord.checkout(pool)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionRecord'>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>

    @classmethod
    def checkout(cls, pool):
>       rec = pool._do_get()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
                return self._create_connection()
            except:
                with util.safe_reraise():
>                   self._dec_overflow()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fe6f84bedd8>
type_ = None, value = None, traceback = None

    def __exit__(self, type_, value, traceback):
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            self._exc_info = None  # remove potential circular references
            if not self.warn_only:
>               compat.reraise(exc_type, exc_value, exc_tb)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tp = <class 'psycopg2.OperationalError'>
value = OperationalError('could not connect to server: Connection refused\n\tIs the server running on host "localhost" (127.0....ction refused\n\tIs the server running on host "localhost" (::1) and accepting\n\tTCP/IP connections on port 5432?\n',)
tb = <traceback object at 0x7fe6f81c82c8>, cause = None

    def reraise(tp, value, tb=None, cause=None):
        if cause is not None:
            assert cause is not value, "Same cause emitted"
            value.__cause__ = cause
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
>       raise value

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>

    def _do_get(self):
        use_overflow = self._max_overflow > -1
    
        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        except sqla_queue.Empty:
            # don't do things inside of "except Empty", because when we say
            # we timed out or can't connect and raise, Python 3 tells
            # people the real error is queue.Empty which it isn't.
            pass
        if use_overflow and self._overflow >= self._max_overflow:
            if not wait:
                return self._do_get()
            else:
                raise exc.TimeoutError(
                    "QueuePool limit of size %d overflow %d reached, "
                    "connection timed out, timeout %d"
                    % (self.size(), self.overflow(), self._timeout),
                    code="3o7r",
                )
    
        if self._inc_overflow():
            try:
>               return self._create_connection()

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>

    def _create_connection(self):
        """Called by subclasses to create a new ConnectionRecord."""
    
>       return _ConnectionRecord(self)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fe6f84befd0>
pool = <sqlalchemy.pool.impl.QueuePool object at 0x7fe6f84bee10>, connect = True

    def __init__(self, pool, connect=True):
        self.__pool = pool
        if connect:
>           self.__connect(first_connect_check=True)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fe6f84befd0>
first_connect_check = True

    def __connect(self, first_connect_check=False):
        pool = self.__pool
    
        # ensure any existing connection is removed, so that if
        # creator fails, this attribute stays None
        self.connection = None
        try:
            self.starttime = time.time()
>           connection = pool._invoke_creator(self)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fe6f84befd0>

    def connect(connection_record=None):
        if dialect._has_events:
            for fn in dialect.dispatch.do_connect:
                connection = fn(
                    dialect, connection_record, cargs, cparams
                )
                if connection is not None:
                    return connection
>       return dialect.connect(*cargs, **cparams)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/strategies.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fe6f8375080>
cargs = ()
cparams = {'database': 'hazen_test', 'host': 'localhost', 'password': 'test_user_password', 'port': 5432, ...}

    def connect(self, *cargs, **cparams):
>       return self.dbapi.connect(*cargs, **cparams)

../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/default.py:453: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost user=test_user password=test_user_password port=5432 dbname=hazen_test'
connection_factory = None, cursor_factory = None
kwargs = {'database': 'hazen_test', 'host': 'localhost', 'password': 'test_user_password', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        if dsn is None and not kwargs:
            raise TypeError('missing dsn and no parameters')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: could not connect to server: Connection refused
E       	Is the server running on host "localhost" (127.0.0.1) and accepting
E       	TCP/IP connections on port 5432?
E       could not connect to server: Connection refused
E       	Is the server running on host "localhost" (::1) and accepting
E       	TCP/IP connections on port 5432?

../venv/hazen/lib/python3.6/site-packages/psycopg2/__init__.py:126: OperationalError

The above exception was the direct cause of the following exception:

self = <tests.test_models.UserModelCase testMethod=test_password_hashing>

    def setUp(self):
        self.app = create_app(TestConfig)
        self.app_context = self.app.app_context()
        self.app_context.push()
>       db.create_all()

tests/test_models.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../venv/hazen/lib/python3.6/site-packages/flask_sqlalchemy/__init__.py:1033: in create_all
    self._execute_for_all_tables(app, bind, 'create_all')
../venv/hazen/lib/python3.6/site-packages/flask_sqlalchemy/__init__.py:1025: in _execute_for_all_tables
    op(bind=self.get_engine(app, bind), **extra)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/sql/schema.py:4287: in create_all
    ddl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2032: in _run_visitor
    with self._optional_conn_ctx_manager(connection) as conn:
/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/contextlib.py:81: in __enter__
    return next(self.gen)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2024: in _optional_conn_ctx_manager
    with self._contextual_connect() as conn:
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2226: in _contextual_connect
    self._wrap_pool_connect(self.pool.connect, None),
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2266: in _wrap_pool_connect
    e, dialect, self
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:1536: in _handle_dbapi_exception_noconnection
    util.raise_from_cause(sqlalchemy_exception, exc_info)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:383: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:128: in reraise
    raise value.with_traceback(tb)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/base.py:2262: in _wrap_pool_connect
    return fn()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:363: in connect
    return _ConnectionFairy._checkout(self)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:760: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:492: in checkout
    rec = pool._do_get()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:139: in _do_get
    self._dec_overflow()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/compat.py:129: in reraise
    raise value
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/impl.py:136: in _do_get
    return self._create_connection()
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:308: in _create_connection
    return _ConnectionRecord(self)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:437: in __init__
    self.__connect(first_connect_check=True)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/pool/base.py:639: in __connect
    connection = pool._invoke_creator(self)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/strategies.py:114: in connect
    return dialect.connect(*cargs, **cparams)
../venv/hazen/lib/python3.6/site-packages/sqlalchemy/engine/default.py:453: in connect
    return self.dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost user=test_user password=test_user_password port=5432 dbname=hazen_test'
connection_factory = None, cursor_factory = None
kwargs = {'database': 'hazen_test', 'host': 'localhost', 'password': 'test_user_password', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        if dsn is None and not kwargs:
            raise TypeError('missing dsn and no parameters')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) could not connect to server: Connection refused
E       	Is the server running on host "localhost" (127.0.0.1) and accepting
E       	TCP/IP connections on port 5432?
E       could not connect to server: Connection refused
E       	Is the server running on host "localhost" (::1) and accepting
E       	TCP/IP connections on port 5432?
E       
E       (Background on this error at: http://sqlalche.me/e/e3q8)

../venv/hazen/lib/python3.6/site-packages/psycopg2/__init__.py:126: OperationalError
------------------------------ Captured log call -------------------------------
INFO     flask.app:__init__.py:85 Hazen startup
=============================== warnings summary ===============================
/Users/lj16/code/venv/hazen/lib/python3.6/site-packages/flask/json/__init__.py:26
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/flask/json/__init__.py:26: DeprecationWarning: Importing 'itsdangerous.json' is deprecated and will be removed in ItsDangerous 2.1. Use Python's 'json' module instead.
    _slash_escape = '\\/' not in _json.dumps('/')

/Users/lj16/code/venv/hazen/lib/python3.6/site-packages/flask/json/__init__.py:48
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/flask/json/__init__.py:48: DeprecationWarning: Importing 'itsdangerous.json' is deprecated and will be removed in ItsDangerous 2.1. Use Python's 'json' module instead.
    class JSONEncoder(_json.JSONEncoder):

/Users/lj16/code/venv/hazen/lib/python3.6/site-packages/flask/json/__init__.py:84
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/flask/json/__init__.py:84: DeprecationWarning: Importing 'itsdangerous.json' is deprecated and will be removed in ItsDangerous 2.1. Use Python's 'json' module instead.
    class JSONDecoder(_json.JSONDecoder):

/Users/lj16/code/venv/hazen/lib/python3.6/site-packages/skimage/__init__.py:71
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/skimage/__init__.py:71: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
    import imp

tests/test_models.py::UserModelCase::test_avatar
tests/test_models.py::UserModelCase::test_password_hashing
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/jinja2/environment.py:362: DeprecationWarning: The 'autoescape' extension is deprecated and will be removed in Jinja 3.1. This is built in now.
    self.extensions = load_extensions(self, extensions)

tests/test_models.py::UserModelCase::test_avatar
tests/test_models.py::UserModelCase::test_password_hashing
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/jinja2/environment.py:362: DeprecationWarning: The 'with' extension is deprecated and will be removed in Jinja 3.1. This is built in now.
    self.extensions = load_extensions(self, extensions)

tests/test_models.py::UserModelCase::test_avatar
  /Users/lj16/code/venv/hazen/lib/python3.6/site-packages/sqlalchemy/util/langhelpers.py:225: SADeprecationWarning: The 'postgres' dialect name has been renamed to 'postgresql'
    loader = self.auto_fn(name)

tests/test_relaxometry.py::TestRelaxometry::test_template_roi_means
tests/test_relaxometry.py::TestRelaxometry::test_template_roi_means
tests/test_relaxometry.py::TestRelaxometry::test_template_roi_means
  /Users/lj16/code/hazen/tests/test_relaxometry.py:425: DeprecationWarning: Please use assertAlmostEqual instead.
    self.ROI_TEMPLATE_MEANS_T0[i])

-- Docs: https://docs.pytest.org/en/latest/warnings.html

---------- coverage: platform darwin, python 3.6.8-final-0 -----------
Name                             Stmts   Miss Branch BrPart  Cover
------------------------------------------------------------------
hazenlib/__init__.py               123     59     48      8    44%
hazenlib/exceptions.py              21      4      6      2    70%
hazenlib/ghosting.py               154     49     58      7    69%
hazenlib/relaxometry.py            308     90    111     10    70%
hazenlib/slice_position.py         107     19     32      5    81%
hazenlib/slice_width.py            287     45     81     10    84%
hazenlib/snr.py                    138     50     38      8    62%
hazenlib/spatial_resolution.py     281     96     90      8    67%
hazenlib/tools.py                   66      9     30      5    85%
hazenlib/uniformity.py              77     21     12      3    73%
------------------------------------------------------------------
TOTAL                             1562    442    506     66    71%

============ 2 failed, 162 passed, 12 warnings in 108.98s (0:01:48) ============
